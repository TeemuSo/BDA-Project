---
title: "Heart Failure Prediction using Bayesian Approach"
author: "Teemu Sormunen, Abdullah Günay, Nicola Brazzale"
date: "11/18/2020"
header-includes:
  - \usepackage[numbers]{natbib}
# Citations
bibliography: ./citations/sources.bib
# csl: ./citations/vancouver-brackets.csl unnecessary?

output: 
  pdf_document:
    toc: true
    toc_depth: 2
    number_sections: true
    citation_package: natbib

---

\newpage

# Introduction

In this project we analyse the data from Heart desease dataset [@origpaper]. We perform a Bayesian analysis of the data using this sequence of operations:
• Overview of analysis problem and of the dataset
• Data preprocsessing and visualisation
• Prior choice discussion
• Models used in our analysis
• $\hat{R}$ convergence
• HMC specific convergence diagnostics
• Effective sample size diagnostic (n_eff or ESS)
• Model comparison
• Prior sensitivity analysis
• Discussion and conclusion

## The problem
Cardiovascular Heart Disease (CHD) is the top reason causing 31% of deaths globally. Pakistan is one of the countries where CHD is increasing significantly, and previous studies do not directly apply to Pakistani area due to different diet patterns.
[@origpaper]

## The motivation
With this project we aim to estimate death events and the major risk factors for heart failure with, possibly, high accuracy [@origpaper].

## Modeling idea

We created 3 models which are then compared based on $\hat{r}$, $n_{eff}$, using the loo package and the classification accuracy. 
The 1st model is the reduced model and consists in fewer varibles which are selected base on their corrolection with the death event. The 2nd model consists in all varibles except for the varibale "time" as we believe that doens't represent an important factor in the death event scenario. The 3rd model used is a hierarchical model where we treated age class patients in a group with respect to the other selected variables. The 4th model is a non-linear model, as the hierarchical one we took in considertion only the selected varibales in the first model.
Modeling is done with package brms, which is a interface for non-linear multivariate multilevel models in Stan.

# Dataset

## Term explanation  

Some of the terms in the dataset might not be familiar, and they are opened briefly here.

* **Creatine phosphokinase (CPK)**  
CPK is an enzyme, which helps to regulate the concentration of adenosine triphosphate (ATP) in cells. ATP is responsible for carrying energy. If the CPK level is high, it often means that there has been an injury or stress on a muscle tissue. Although CPK is one the oldest markers of heart attack, high CPK might also indicate of acute muscle injury along with acute heart problems.  
Normal level of CPK ranges from 20 to 200 IU/L [@phosphokinase]

* **Ejection fraction (EF)**  
EF is a measurement in percentage which describes how much blood left ventricle pumps out of heart with each contraction.
Low EF might indicate potential heart issues.  
Normal EF is 50 to 70 percent, while measurement under 40 percept might be an indicator of heart failure or cardiomyopathy. [@ef]  

* **Platelets**  
Platelets are small cell fragments which can form clots. 
Too many platelets can lead to clotting of blood vessels, 
which in turn can lead to heart attack. Too 
Normal range of platelets is from 150 000 to 450 000. [@platelets]

* **Serum creatinine**  
When creatine breaks down, it forms a waste product called creatinine. Kidneys normally remove creatinine from body. Serum creatinine measures level of creatinine in the blood, indicating the kidney health. High levels of creatinine might indicate a kidney dysfunctioning.  
Normal level of creatinine range from 0.9 to 1.3 mg/dL in men and 0.6 to 1.1 mg/dL in women who are 18 to 60 years old. [@creatinine_serum]

* **Serum sodium**  
Serum sodium measures the amount of sodium in blood. Sodium enters blood through food and drink, and leaves by urine, stool and sweat. Too much sodium can cause blood pressure, while too little sodium can cause nausea, vomiting, exhaustion or dizziness.  
Normal levels of serum sodium are 135 to 145 mEq/L, according to Mayo Clinic. There are however different interpretations of "normal".[@sodium]

## Dataset introduction

The dataset of 299 patients was produced as a result of study [@origpaper] from Pakistani's city Faisalabad. All of the patients were over 40 years old, each having ventricular systolic dysfunction. This means that patient has poor left ventricular ejection fraction.
The dataset has 105 women, and 194 men.
EF, serum creatinine and platelets are categorical variables, and age, serum sodium and CPK are continuous variables.  
Statistical analysis by [@origpaper] found age, creatinine, sodium, anemia and BP as significant variables.  

We decided to treat DEATH_EVENT as binary variable, indicating whether patient has died or stayed alive for the duration of the study period. For this purpose we ignored time variable completely. However, we also wanted to try survival analysis with respect to the timestamp, and using DEATH_EVENT as censoring variable, so we implemented a fourth model. 
 
\newpage
# Packages
```{r setup, include=FALSE}
library(tidyverse)
library(ggplot2)
library(corrplot)
library(brms)
library(rstanarm)
library(loo)
```

Load data
```{r}
file.name <- './data/heart_failure_clinical_records_dataset.csv'
heart <- read_csv(file.name)
```
Prevent text overflow on PDF
```{r}
library(knitr)
opts_chunk$set(tidy.opts=list(width.cutoff=60),tidy=TRUE)
```

# Data preprocessing and visualization

## Plot histograms

```{r}
ggplot(heart, aes(x=age)) + geom_histogram(aes(fill=as.character(sex)), bins = 30) + labs(fill = "Sex")

ggplot(heart, aes(x=age)) + geom_histogram(aes(fill=as.character(DEATH_EVENT)), bins = 30) + labs(fill = "Death")

ggplot(heart, aes(x=creatinine_phosphokinase)) + geom_histogram(aes(fill=as.character(DEATH_EVENT)), bins = 30) + labs(fill = "Death")

ggplot(heart, aes(x=ejection_fraction)) + geom_histogram(aes(fill=as.character(DEATH_EVENT)), bins = 30) + labs(fill = "Death")

ggplot(heart, aes(x=platelets)) + geom_histogram(aes(fill=as.character(DEATH_EVENT)), bins = 30) + labs(fill = "Death")

ggplot(heart, aes(x=serum_creatinine)) + geom_histogram(aes(fill=as.character(DEATH_EVENT)), bins = 30) + labs(fill = "Death")

```

## Correlation matrix

```{r}
pred <- c("high_blood_pressure", "age", "sex", "creatinine_phosphokinase", "diabetes", "ejection_fraction", "platelets", "serum_creatinine", "serum_sodium", "smoking", "anaemia", "time") 
target <- c("DEATH_EVENT")
#formula <- paste("DEATH_EVENT ~", paste(pred, collapse = "+"))
p <- length(pred)
n <- nrow(heart)
x = cor(heart[, c(target,pred)]) 
corrplot(x)
```

## General functions
For testing purposes
```{r}
predict.pointwise.accuracy <- function(fitted.model, test.data) {
  preds <- round(predict(fitted.model, newdata = test.data)[,1])
  preds.correct <- preds == test.data$DEATH_EVENT

  pointwise.accuracy <- length(preds.correct[preds.correct == TRUE])/nrow(test.data)
  
  return(pointwise.accuracy)
}
```


# Models

We chose to use BRMS for modeling. It stands for Bayesian Regression Models for Stan. It's an interface to fit Bayesian generalized (non-)linear multivariate models using Stan. As we need to do analysis for binary response variables, we need some sort of a generalized linear model. We also chose BRMS due to its ease of use when fitting such complicated multilevel generalized linear models.

In BRMS modeling, the parameters are said to either be population level or group level. Population-level parameters means the same thing as regular parameters in our course, and group-level parameters mean hyperparameters in hierarchical case.  

Brms example, investigate results based on age.
**Family argument** specifies the distribution family of the output.  

**Prior argument** for each of the parameters, in this case only age. One can set different priors for each population level parameter, or group level parameter.
```{r}
# Split test and train data
test.size <- 0.3
train.indice <- sample(nrow(heart), nrow(heart)*(1-test.size))
train.data <- heart[train.indice,]
test.data <- heart[-train.indice,]
```

## Prior choices 

The types of priors we considered in this project are uniformative priors and regularizing priors. Surely this dataset is not the only one about heart failure but since no prior knowledge are provided in the original papers we opted for using uninformative priors.  

By default BRMS uses improper flat prior over the reals for population level parameters. Group level parameter is assumed to come from multivariate normal distribution with zero mean and unknown covariance matrix. 

## Model fitting

The Generalised Linear Model used for every parametrisation is Bernoulli-Logit Generalised Linear Model, which is logistic regression. It's expressed in mathematical terms as following:  
$BernoulliLogitGLM(y|x,\alpha, \beta) = \prod_{1\leq i\leq n} Bernoulli(y_i | logit^{-1}(\alpha_i + x_i\times \beta))$


### Full model

Stan code for full model can be found in Appendix A.  
Full model includes all the parameters that are specified in the dataset.

```{r}
fit.full <- brm(formula = DEATH_EVENT ~ age + ejection_fraction + serum_creatinine + serum_sodium + high_blood_pressure + creatinine_phosphokinase + diabetes + smoking + anaemia,
           data = train.data,
           family = bernoulli(),
           refresh=0
)
```

### WIP: Feature selected model

Stan code for feature selected model can be found in Appendix B.  

In feature selected model, we hand pick the features that seems to be the most promising with regards to fitting the model. As described above, we saw that ejection_fraction, serum_creatinine, serum_sodium and age were correlating highly to death. 

```{r}
fit.feature_selected <- brm(formula = DEATH_EVENT ~ ejection_fraction + serum_creatinine + serum_sodium + age,
                            data = train.data,
                            family = bernoulli(),
                            refresh = 0
                            )
```



### Hierarchical model

Stan code for hierarchical model can be found in Appendix C.  

In hierarchical model, we choose age as hyperparameter.  
First we will discretize age data in to 3 equal depth bins.  
Doing

```{r}
heart$age[heart$age<=55] = 0
heart$age[heart$age>55 & heart$age<70] = 1
heart$age[heart$age>=70] = 2
hist(heart$age)
```

Then we can fit the model
```{r}
fit.hierarchical <- brm(formula = DEATH_EVENT ~ ejection_fraction + serum_creatinine + serum_sodium + (ejection_fraction + serum_creatinine + serum_sodium| age),
           data = train.data,
           family = bernoulli(),
           refresh=0,
           control = list(adapt_delta = 0.99),
           save_all_pars=T,
           save_pars=save_pars(all = T)
)
```

### Model for death time analysis
As a fourth model we have model with response variable according to Weibull distribution, and features are selected based on correlation matrix.
```{r}
fit.weibull <- brm(formula = time | cens(DEATH_EVENT) ~ high_blood_pressure + age + serum_creatinine + serum_sodium,
           data = train.data,
           family = weibull(),
           refresh=0
)
```

## $\hat{R}$ convergence 

## HMC specific convergence diagnostics (divergences, tree depth) with interpretation of the results


## Effective sample size diagnostic (n_eff or ESS) and an interpretation of the results


## Posterior predictive checking and interpretation of the results

## Model comparison and interpretation of the results

## WIP: Predictive performance assessment (classification)

### Full model

```{r}
loo.full <-loo(fit.full)

hist(loo.full$diagnostics$pareto_k, main = "Diagnostic histogram of Pareto k",  xlab = "k-values", 
     ylab = "Frequency", freq = FALSE)
```

### Feature selected model

```{r}
loo.feature_selected <-loo(fit.feature_selected)

hist(loo.feature_selected$diagnostics$pareto_k, main = "Diagnostic histogram of Pareto k",  xlab = "k-values", 
     ylab = "Frequency", freq = FALSE)
```

### Hierarchical model
```{r}
loo.hier <- loo(fit.hierarchical)

hist(loo.hier$diagnostics$pareto_k, main = "Diagnostic histogram of Pareto k",  xlab = "k-values", 
     ylab = "Frequency",
     freq = FALSE)
```

## Prior sensitivity analysis (alternative prior tested)

## Discussion of problems and further improvements



NON-LINEAR SCRAP CODE:
```{r}
#NON LINEAR 
fitNonLinear <- brm(formula = DEATH_EVENT ~ s(ejection_fraction) + s(serum_creatinine) + s(serum_sodium), data = train.data, family = "gaussian", refresh=0)
```

# Conclusion

# Self-reflection

As a group we have learned...

\newpage
# Appendix {-}

## A. Stan code of full model {-}
```{r}
stancode(fit.full)
```

\newpage
## B. Stan feature selected model {-}
```{r}
stancode(fit.feature_selected)
```

\newpage
## C. Stan hierarhical model {-}
```{r}
stancode(fit.hierarchical)
```

\newpage
# References